<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Ping Pong Game</title>
	<style>
		body {
			background: #181818;
			color: #fff;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			height: 100vh;
			margin: 0;
		}
		h1 {
			margin-bottom: 20px;
		}
		canvas {
			background: #222;
			display: block;
			margin: 0 auto;
			border: 2px solid #fff;
			border-radius: 10px;
			width: 700px;
			height: 400px;
			image-rendering: pixelated;
		}
		.score {
			font-size: 1.5em;
			margin-bottom: 10px;
		}
	</style>
</head>
<body>
	<h1>Ping Pong</h1>
	<div class="score" id="score">0 : 0</div>
	<canvas id="pong" width="700" height="400"></canvas>
	<script>
	const canvas = document.getElementById('pong');
	// Prevent canvas stretching: set width/height attributes and style to match
	canvas.width = 700;
	canvas.height = 400;
	const ctx = canvas.getContext('2d');
		const scoreDiv = document.getElementById('score');

		// Game objects
		const paddleWidth = 12, paddleHeight = 80;
		const player = {
			x: 10,
			y: canvas.height/2 - paddleHeight/2,
			width: paddleWidth,
			height: paddleHeight,
			dy: 0,
			speed: 6
		};
		const ai = {
			x: canvas.width - paddleWidth - 10,
			y: canvas.height/2 - paddleHeight/2,
			width: paddleWidth,
			height: paddleHeight,
			dy: 0,
			speed: 3.7 // slightly slower, more human
		};
		// Bird obstacles
		const birds = [];
		let birdsActive = false;
		let birdTimer = 0;
		let birdInterval = 5 * 60 * 1000; // 5 minutes in ms
		let birdDuration = 6000; // birds stay for 6 seconds
		let lastBirdTime = Date.now();

		function spawnBirds() {
			birds.length = 0;
			let numBirds = 2 + Math.floor(Math.random()*2);
			for(let i=0; i<numBirds; i++) {
				// Float in a band in the upper third of the screen
				let y = 30 + Math.random() * (canvas.height/3 - 40);
				let speed = 2.2 + Math.random()*1.2;
				let floatAmp = 18 + Math.random()*10;
				let floatFreq = 0.002 + Math.random()*0.001;
				birds.push({
					x: -60 - i*120,
					y: y,
					baseY: y,
					w: 48,
					h: 32,
					speed: speed,
					floatAmp: floatAmp,
					floatFreq: floatFreq,
					floatPhase: Math.random()*Math.PI*2
				});
			}
			birdsActive = true;
			birdTimer = Date.now();
		}

		function updateBirds() {
			if(!birdsActive) return;
			let t = Date.now();
			for(let bird of birds) {
				bird.x += bird.speed;
				bird.y = bird.baseY + Math.sin(t*bird.floatFreq + bird.floatPhase) * bird.floatAmp;
			}
			// Remove birds after duration
			if(Date.now() - birdTimer > birdDuration) {
				birdsActive = false;
				birds.length = 0;
				lastBirdTime = Date.now();
			}
		}

		function drawBirds() {
			if(!birdsActive) return;
			for(let bird of birds) {
				// Simple bird: body + wings
				ctx.save();
				ctx.translate(bird.x, bird.y);
				ctx.fillStyle = '#ff0';
				ctx.beginPath();
				ctx.ellipse(24, 16, 22, 12, 0, 0, Math.PI*2);
				ctx.fill();
				// Wings
				ctx.strokeStyle = '#fff';
				ctx.lineWidth = 3;
				ctx.beginPath();
				ctx.moveTo(10, 16);
				ctx.lineTo(0, 4 + 8*Math.sin(Date.now()/120));
				ctx.moveTo(38, 16);
				ctx.lineTo(48, 4 + 8*Math.sin(Date.now()/120));
				ctx.stroke();
				ctx.restore();
			}
		}
		const ball = {
			x: canvas.width/2,
			y: canvas.height/2,
			radius: 10,
			speed: 5,
			dx: 5 * (Math.random() > 0.5 ? 1 : -1),
			dy: 3 * (Math.random() > 0.5 ? 1 : -1)
		};
	let playerScore = 0, aiScore = 0;
	let gameOver = false;
		// More obstacles: clouds and balloons
		const clouds = [];
		let cloudsActive = false;
		let cloudTimer = 0;
		let cloudInterval = 2.5 * 60 * 1000; // every 2.5 minutes
		let cloudDuration = 5000;
		let lastCloudTime = Date.now();

		const balloons = [];
		let balloonsActive = false;
		let balloonTimer = 0;
		let balloonInterval = 3.5 * 60 * 1000; // every 3.5 minutes
		let balloonDuration = 5000;
		let lastBalloonTime = Date.now();

		function spawnClouds() {
			clouds.length = 0;
			let numClouds = 1 + Math.floor(Math.random()*2);
			for(let i=0; i<numClouds; i++) {
				// Float in the middle third
				let y = canvas.height/3 + Math.random() * (canvas.height/3 - 60);
				let speed = 0.8 + Math.random()*0.7;
				let floatAmp = 16 + Math.random()*8;
				let floatFreq = 0.001 + Math.random()*0.001;
				clouds.push({
					x: -100 - i*120,
					y: y,
					baseY: y,
					w: 80,
					h: 40,
					speed: speed,
					floatAmp: floatAmp,
					floatFreq: floatFreq,
					floatPhase: Math.random()*Math.PI*2
				});
			}
			cloudsActive = true;
			cloudTimer = Date.now();
		}

		function updateClouds() {
			if(!cloudsActive) return;
			let t = Date.now();
			for(let cloud of clouds) {
				cloud.x += cloud.speed;
				cloud.y = cloud.baseY + Math.sin(t*cloud.floatFreq + cloud.floatPhase) * cloud.floatAmp;
			}
			if(Date.now() - cloudTimer > cloudDuration) {
				cloudsActive = false;
				clouds.length = 0;
				lastCloudTime = Date.now();
			}
		}

		function drawClouds() {
			if(!cloudsActive) return;
			for(let cloud of clouds) {
				ctx.save();
				ctx.globalAlpha = 0.7;
				ctx.fillStyle = '#fff';
				ctx.beginPath();
				ctx.ellipse(cloud.x+30, cloud.y+20, 30, 20, 0, 0, Math.PI*2);
				ctx.ellipse(cloud.x+55, cloud.y+25, 25, 15, 0, 0, Math.PI*2);
				ctx.ellipse(cloud.x+15, cloud.y+30, 20, 12, 0, 0, Math.PI*2);
				ctx.fill();
				ctx.globalAlpha = 1.0;
				ctx.restore();
			}
		}

		function spawnBalloons() {
			balloons.length = 0;
			let numBalloons = 1 + Math.floor(Math.random()*2);
			for(let i=0; i<numBalloons; i++) {
				// Float in the lower third
				let x = 100 + Math.random() * (canvas.width-200);
				let y = canvas.height*2/3 + Math.random() * (canvas.height/3 - 60);
				let speed = 0.7 + Math.random()*0.7;
				let floatAmp = 16 + Math.random()*8;
				let floatFreq = 0.001 + Math.random()*0.001;
				balloons.push({
					x: x,
					y: y,
					baseX: x,
					baseY: y,
					w: 24,
					h: 36,
					speed: speed,
					floatAmp: floatAmp,
					floatFreq: floatFreq,
					floatPhase: Math.random()*Math.PI*2
				});
			}
			balloonsActive = true;
			balloonTimer = Date.now();
		}

		function updateBalloons() {
			if(!balloonsActive) return;
			let t = Date.now();
			for(let balloon of balloons) {
				balloon.y -= balloon.speed;
				balloon.x = balloon.baseX + Math.sin(t*balloon.floatFreq + balloon.floatPhase) * balloon.floatAmp;
			}
			if(Date.now() - balloonTimer > balloonDuration) {
				balloonsActive = false;
				balloons.length = 0;
				lastBalloonTime = Date.now();
			}
		}

		function drawBalloons() {
			if(!balloonsActive) return;
			for(let balloon of balloons) {
				ctx.save();
				ctx.fillStyle = '#e33';
				ctx.beginPath();
				ctx.ellipse(balloon.x, balloon.y, 12, 18, 0, 0, Math.PI*2);
				ctx.fill();
				ctx.strokeStyle = '#fff';
				ctx.beginPath();
				ctx.moveTo(balloon.x, balloon.y+18);
				ctx.lineTo(balloon.x, balloon.y+30);
				ctx.stroke();
				ctx.restore();
			}
		}

		function drawRect(x, y, w, h, color) {
			ctx.fillStyle = color;
			ctx.fillRect(x, y, w, h);
		}
		function drawCircle(x, y, r, color) {
			ctx.fillStyle = color;
			ctx.beginPath();
			ctx.arc(x, y, r, 0, Math.PI*2);
			ctx.closePath();
			ctx.fill();
		}
		function drawNet() {
			ctx.fillStyle = '#fff4';
			for(let i=0; i<canvas.height; i+=24) {
				ctx.fillRect(canvas.width/2-2, i, 4, 16);
			}
		}
		function draw() {
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			drawNet();
			drawClouds();
			drawRect(player.x, player.y, player.width, player.height, '#0ff');
			drawRect(ai.x, ai.y, ai.width, ai.height, '#f0f');
			drawBirds();
			drawBalloons();
			drawCircle(ball.x, ball.y, ball.radius, '#fff');
			if(gameOver) {
				ctx.save();
				ctx.fillStyle = '#fff';
				ctx.font = 'bold 40px sans-serif';
				ctx.textAlign = 'center';
				ctx.fillText('You Win!', canvas.width/2, canvas.height/2);
				ctx.font = '20px sans-serif';
				ctx.fillText('Refresh to play again', canvas.width/2, canvas.height/2+40);
				ctx.restore();
			}
		}

		function resetBall() {
			ball.x = canvas.width/2;
			ball.y = canvas.height/2;
			ball.dx = ball.speed * (Math.random() > 0.5 ? 1 : -1);
			ball.dy = 3 * (Math.random() > 0.5 ? 1 : -1);
		}

		function update() {
			if(gameOver) return;

			// Obstacles spawn
			if(!birdsActive && Date.now() - lastBirdTime > birdInterval) {
				spawnBirds();
			}
			if(!cloudsActive && Date.now() - lastCloudTime > cloudInterval) {
				spawnClouds();
			}
			if(!balloonsActive && Date.now() - lastBalloonTime > balloonInterval) {
				spawnBalloons();
			}
			updateBirds();
			updateClouds();
			updateBalloons();

			// Move player
			player.y += player.dy;
			if(player.y < 0) player.y = 0;
			if(player.y + player.height > canvas.height) player.y = canvas.height - player.height;

			// AI movement (hard but beatable)
			let aiCenter = ai.y + ai.height/2;
			// Add a small reaction delay and error margin
			let aiTarget = ball.y + (Math.random()-0.5)*32;
			if(ball.x > canvas.width/2) { // AI only reacts when ball is on its side
				if(aiTarget < aiCenter - 12) {
					ai.dy = -ai.speed;
				} else if(aiTarget > aiCenter + 12) {
					ai.dy = ai.speed;
				} else {
					ai.dy = 0;
				}
			} else {
				ai.dy = 0;
			}
			ai.y += ai.dy * 0.85; // smoothness
			if(ai.y < 0) ai.y = 0;
			if(ai.y + ai.height > canvas.height) ai.y = canvas.height - ai.height;

			// Ball movement
			ball.x += ball.dx;
			ball.y += ball.dy;

			// Top/bottom collision
			if(ball.y - ball.radius < 0 || ball.y + ball.radius > canvas.height) {
				ball.dy = -ball.dy;
			}

			// Bird collision (ball)
			let ballReset = false;
			if(birdsActive) {
				for(let bird of birds) {
					if(
						ball.x + ball.radius > bird.x &&
						ball.x - ball.radius < bird.x + bird.w &&
						ball.y + ball.radius > bird.y &&
						ball.y - ball.radius < bird.y + bird.h
					) {
						ballReset = true;
					}
				}
			}
			// Cloud collision (ball)
			if(cloudsActive) {
				for(let cloud of clouds) {
					if(
						ball.x + ball.radius > cloud.x &&
						ball.x - ball.radius < cloud.x + cloud.w &&
						ball.y + ball.radius > cloud.y &&
						ball.y - ball.radius < cloud.y + cloud.h
					) {
						ballReset = true;
					}
				}
			}
			// Balloon collision (ball)
			if(balloonsActive) {
				for(let balloon of balloons) {
					if(
						ball.x + ball.radius > balloon.x-12 &&
						ball.x - ball.radius < balloon.x+12 &&
						ball.y + ball.radius > balloon.y-18 &&
						ball.y - ball.radius < balloon.y+18
					) {
						ballReset = true;
					}
				}
			}
			if(ballReset) {
				ball.speed = 5;
				resetBall();
				return;
			}

			// Paddle collision
			let paddle = (ball.x < canvas.width/2) ? player : ai;
			if(
				ball.x - ball.radius < paddle.x + paddle.width &&
				ball.x + ball.radius > paddle.x &&
				ball.y + ball.radius > paddle.y &&
				ball.y - ball.radius < paddle.y + paddle.height
			) {
				// Reflect ball, add some randomness
				let collidePoint = (ball.y - (paddle.y + paddle.height/2));
				collidePoint = collidePoint / (paddle.height/2);
				let angleRad = collidePoint * (Math.PI/4);
				let direction = (ball.x < canvas.width/2) ? 1 : -1;
				ball.dx = direction * ball.speed * Math.cos(angleRad);
				ball.dy = ball.speed * Math.sin(angleRad);
				// Slightly increase speed
				ball.speed *= 1.03;
			}

			// Score
			if(ball.x - ball.radius < 0) {
				aiScore++;
				updateScore();
				ball.speed = 5;
				resetBall();
			} else if(ball.x + ball.radius > canvas.width) {
				playerScore++;
				updateScore();
				ball.speed = 5;
				resetBall();
				if(playerScore >= 5) {
					gameOver = true;
					setTimeout(() => {
						window.location.href = 'TheRealGxmesBegin.html';
					}, 1000);
				}
			}
		}

		function updateScore() {
			scoreDiv.textContent = playerScore + ' : ' + aiScore;
		}

		// Controls
		document.addEventListener('keydown', e => {
			if(e.key === 'ArrowUp' || e.key === 'w') player.dy = -player.speed;
			if(e.key === 'ArrowDown' || e.key === 's') player.dy = player.speed;
		});
		document.addEventListener('keyup', e => {
			if((e.key === 'ArrowUp' || e.key === 'w') && player.dy < 0) player.dy = 0;
			if((e.key === 'ArrowDown' || e.key === 's') && player.dy > 0) player.dy = 0;
		});

		// Touch controls for mobile
		canvas.addEventListener('touchstart', e => {
			let touchY = e.touches[0].clientY - canvas.getBoundingClientRect().top;
			if(touchY < player.y + player.height/2) player.dy = -player.speed;
			else player.dy = player.speed;
		});
		canvas.addEventListener('touchend', e => {
			player.dy = 0;
		});

		function gameLoop() {
			update();
			draw();
			requestAnimationFrame(gameLoop);
		}
		updateScore();
		gameLoop();
	</script>
</body>
</html>
